# 1. [DC-11]Unsafe PRNG in Math Library

## 1.1. Tag

`crypto`

`rand`

`PRNG`

## 1.2. Vulnerability description

Security risk is from the improper use of random number generator like `math/rand`.

## 1.3. Vulnerability analysis

`math/rand` is a pseudo-random number generator. When it uses the default `Top-level` function like `Float64` or `Int`, it uses default seed `1` or other fixed value seed. The result it produces doesn't change if the same seed is used. This mechanism of generating random number brings the risk of guessing. Even `time.Now().UnixNano` is used, the problem also exists because the pattern can be observed
frequently.

`Package math/rand` official document：

>Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.

 `Seed` Method explain here：

> Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2^31-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use.

File path：`p2p/pex/addrbook.go`

```go
pickFromOldBucket := (newCorrelation+oldCorrelation)*rand.Float64() < oldCorrelation

// code ...

for len(bucket) == 0 {
    if pickFromOldBucket {
        bucket = a.bucketsOld[rand.Intn(len(a.bucketsOld))]
    } else {
        bucket = a.bucketsNew[rand.Intn(len(a.bucketsNew))]
    }
}

// code ...

randIndex := rand.Intn(len(bucket))
```

Improper use of `math/rand` will bring the risk of pseudo-random number. Since the single seed is used, the generator behaves as if seeded by Seed(1). Note `math/rand` generate parallel random results. That is to say, the first instance generates `81 87 47 59 81 18 ...`, and the second instance generates `81 87 47 59 81 18 ...` too. Therefore the random number is easy to guess.

## 1.4. Reproduce

Use the demo script to test:

```go
package main

import "fmt"
import "math/rand"

func main() {
    fmt.Println(rand.Intn(100)) // Produce random interger ranging 1-100
    fmt.Println(rand.Intn(100)) // Produce random interger ranging 1-100
    fmt.Println(rand.Intn(100)) // Produce random interger ranging 1-100
    fmt.Println(rand.Intn(100)) // Produce random interger ranging 1-100
    fmt.Println(rand.Intn(100)) // Produce random interger ranging 1-100
    fmt.Println(rand.Intn(100)) // Produce random interger ranging 1-100

    fmt.Println(rand.Float64()) // Produce random float number ranging 0.0-1.0
    fmt.Println(rand.Float64()) // Produce random float number ranging 0.0-1.0
    fmt.Println(rand.Float64()) // Produce random float number ranging 0.0-1.0
    fmt.Println(rand.Float64()) // Produce random float number ranging 0.0-1.0
    fmt.Println(rand.Float64()) // Produce random float number ranging 0.0-1.0
    fmt.Println(rand.Float64()) // Produce random float number ranging 0.0-1.0
}
```

Though we ran it many times, the results didn't change.

```bash
81
87
47
59
81
18
0.06563701921747622
0.15651925473279124
0.09696951891448456
0.30091186058528707
0.5152126285020654
0.8136399609900968
```

## 1.5. Fix

Use `crypto/rand` instead of `math/rand` to produce random number，then the problem can be solved.

```golang
func NewCryptoSeededSource() mrand.Source {
    var seed int64
    binary.Read(crand.Reader, binary.BigEndian, &seed)
    return mrand.NewSource(seed)
}

func BenchmarkSeed(b *testing.B) {
    random := mrand.New(NewCryptoSeededSource())
    for n := 0; n < b.N; n++ {
        result = random.Intn(7919)
    }
}
```

Here we use a safe method in `random.go` to generate a random number.

```go
pickFromOldBucket := (newCorrelation+oldCorrelation)*a.rand.Float64() < oldCorrelation

// code ...

for len(bucket) == 0 {
    if pickFromOldBucket {
        bucket = a.bucketsOld[a.rand.Intn(len(a.bucketsOld))]
    } else {
        bucket = a.bucketsNew[a.rand.Intn(len(a.bucketsNew))]
    }
}

// code ...

randIndex := a.rand.Intn(len(bucket))
```

## 1.6. Additional Information

Please note that original vulnerability exists in `common/random.go#L13-L21`. It uses the PRNG of library `math/rand`, though it set its own seed, it's risky.

```go
func init() {
    b := cRandBytes(8)
    var seed uint64
    for i := 0; i < 8; i++ {
        seed |= uint64(b[i])
        seed <<= 8
    }
    rand.Seed(int64(seed))
}
```

But the problem lies that if the seed is reset in another place, the generation of pseudo-random number will be influenced. Therefore a better way to code is dividing instances by combined structure `Rand`, and use `Seed`, `reset` to reset instances of different seeds.

```go
import (
    crand "crypto/rand"
    mrand "math/rand"
)

type Rand struct {
    sync.Mutex
    rand *mrand.Rand
}

func (r *Rand) init() {
    bz := cRandBytes(8)
    var seed uint64
    for i := 0; i < 8; i++ {
        seed |= uint64(bz[i])
        seed <<= 8
    }
    r.reset(int64(seed))
}

func (r *Rand) reset(seed int64) {
    r.rand = mrand.New(mrand.NewSource(seed))
}

// code ...

func (r *Rand) Seed(seed int64) {
    r.Lock()
    r.reset(seed)
    r.Unlock()
}
```

## 1.7. Reference

[math/rand](https://golang.org/pkg/math/rand/)

[func Seed](https://golang.org/pkg/math/rand/#Seed)

You can check the related issue : [Issue](https://github.com/tendermint/tendermint/issues/973)

Vulnerable code: [Link](https://github.com/tendermint/tmlibs/pull/121/files)