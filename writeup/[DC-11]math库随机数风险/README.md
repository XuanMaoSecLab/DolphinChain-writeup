# 1. [DC-11]math库随机数风险

## 1.1. 漏洞标签

`crypto` `rand` `PRNG`

## 1.2. 漏洞描述

对 `math/rand` 函数生成随机数机制了解不足，不正确的使用将使应用存在安全风险。

## 1.3. 漏洞分析

`math/rand`为伪随机数生成器，使用默认的`Top-level`函数如 `Float64`、`Int`时，其隐含地使用`1`作为种子，或者使用其它固定的种子时，每次运行时产生相同的输出，有被猜测的风险。或者使用模式能够被频繁观察到的数值作为种子，如 `time.Now().UnixNano()`,这时也可能会产生问题。

`Package math/rand` 官方文档说明：

>Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.

其中 `Seed` 方法说明：

> Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2^31-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use.

文件：`p2p/pex/addrbook.go`

```go
pickFromOldBucket := (newCorrelation+oldCorrelation)*rand.Float64() < oldCorrelation

// code ...

for len(bucket) == 0 {
    if pickFromOldBucket {
        bucket = a.bucketsOld[rand.Intn(len(a.bucketsOld))]
    } else {
        bucket = a.bucketsNew[rand.Intn(len(a.bucketsNew))]
    }
}

// code ...

randIndex := rand.Intn(len(bucket))
```

不正确地使用 `math/rand` ，存在随机数风险。因为使用唯一的种子，可以抽象为 `rand.Seed(1)`。因为 `math/rand` 每一次产生的随机数都是平行的。即第一个实例中产生的随机数为 `81 87 47 59 81 18 ...`，第二个实例中产生的也为 `81 87 47 59 81 18 ...`，极易被猜测。

## 1.4. 复现或测试步骤

此处使用示例代码测试:

```go
package main

import "fmt"
import "math/rand"

func main() {
	fmt.Println(rand.Intn(100)) // 产生0-100的随机整数
	fmt.Println(rand.Intn(100)) // 产生0-100的随机整数
	fmt.Println(rand.Intn(100)) // 产生0-100的随机整数
	fmt.Println(rand.Intn(100)) // 产生0-100的随机整数
	fmt.Println(rand.Intn(100)) // 产生0-100的随机整数
	fmt.Println(rand.Intn(100)) // 产生0-100的随机整数

	fmt.Println(rand.Float64()) // 产生0.0-1.0的随机浮点数
	fmt.Println(rand.Float64()) // 产生0.0-1.0的随机浮点数
	fmt.Println(rand.Float64()) // 产生0.0-1.0的随机浮点数
	fmt.Println(rand.Float64()) // 产生0.0-1.0的随机浮点数
	fmt.Println(rand.Float64()) // 产生0.0-1.0的随机浮点数
	fmt.Println(rand.Float64()) // 产生0.0-1.0的随机浮点数
}
```

运行多次，可以看到，每次输出的结果均为 ：

```bash
81
87
47
59
81
18
0.06563701921747622
0.15651925473279124
0.09696951891448456
0.30091186058528707
0.5152126285020654
0.8136399609900968
```

## 1.5. 修复

使用 `crypto/rand` 来作为 `math/rand` 的种子，可以解决上述问题，如：

```golang
func NewCryptoSeededSource() mrand.Source {
	var seed int64
	binary.Read(crand.Reader, binary.BigEndian, &seed)
	return mrand.NewSource(seed)
}

func BenchmarkSeed(b *testing.B) {
	random := mrand.New(NewCryptoSeededSource())
	for n := 0; n < b.N; n++ {
		result = random.Intn(7919)
	}
}
```

而此处的修复方式为调用 `random.go` 中的较为安全的产生随机数方法 ：

```go
pickFromOldBucket := (newCorrelation+oldCorrelation)*a.rand.Float64() < oldCorrelation

// code ...

for len(bucket) == 0 {
    if pickFromOldBucket {
        bucket = a.bucketsOld[a.rand.Intn(len(a.bucketsOld))]
    } else {
        bucket = a.bucketsNew[a.rand.Intn(len(a.bucketsNew))]
    }
}

// code ...

randIndex := a.rand.Intn(len(bucket))
```

## 1.6. 延伸

注意，参考的原 `tendermint` 漏洞为在 `common/random.go#L13-L21` 中完全使用库的随机数，在初始化时有设置种子。

```go
func init() {
	b := cRandBytes(8)
	var seed uint64
	for i := 0; i < 8; i++ {
		seed |= uint64(b[i])
		seed <<= 8
	}
	rand.Seed(int64(seed))
}
```

但问题在于，如果有其它地方重新设置了种子，会影响伪随机数的产生，因此改成以组合结构体`Rand`的形式划分实例，并使用 `Seed`、`reset`，随时重置不同种子的随机数实例。

```go
import (
	crand "crypto/rand"
	mrand "math/rand"
)

type Rand struct {
	sync.Mutex
	rand *mrand.Rand
}

func (r *Rand) init() {
	bz := cRandBytes(8)
	var seed uint64
	for i := 0; i < 8; i++ {
		seed |= uint64(bz[i])
		seed <<= 8
	}
	r.reset(int64(seed))
}

func (r *Rand) reset(seed int64) {
	r.rand = mrand.New(mrand.NewSource(seed))
}

// code ...

func (r *Rand) Seed(seed int64) {
	r.Lock()
	r.reset(seed)
	r.Unlock()
}
```

## 1.7. 相关资料

[math/rand](https://golang.org/pkg/math/rand/)

[func Seed](https://golang.org/pkg/math/rand/#Seed)

本漏洞相关 `Issue` 见 : [Issue](https://github.com/tendermint/tendermint/issues/973)

漏洞代码: [链接](https://github.com/tendermint/tmlibs/pull/121/files)